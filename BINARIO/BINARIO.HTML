<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel Santos Grillo - Binary Matrix</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            display: block;
            background: #000;
            width: 100%;
            height: 300px;
            max-width: 1200px;
        }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>

    <script>
        function textToBinary(text) {
            return text.split('').map(char => {
                return char.charCodeAt(0).toString(2).padStart(8, '0');
            }).join('');
        }

        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');

        canvas.width = 1200;
        canvas.height = 300;

        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);

        // Nombres en binario
        const gabrielBinary = textToBinary("GABRIEL");
        const santosBinary = textToBinary("SANTOS");
        const grilloBinary = textToBinary("GRILLO");

        // Calcular posiciones centradas para todos los nombres
        // GABRIEL = 7 letras = 56 chars binarios
        // SANTOS = 6 letras = 48 chars binarios  
        // GRILLO = 6 letras = 48 chars binarios
        
        const gabrielLen = gabrielBinary.length;
        const santosLen = santosBinary.length;
        const grilloLen = grilloBinary.length;
        
        const namePositions = {
            gabriel: { 
                y: 5,
                startCol: Math.floor((columns - gabrielLen) / 2),
                chars: gabrielBinary.split(''),
                startTime: 1000
            },
            santos: { 
                y: 10,
                startCol: Math.floor((columns - santosLen) / 2),
                chars: santosBinary.split(''),
                startTime: 3000
            },
            grillo: { 
                y: 15,
                startCol: Math.floor((columns - grilloLen) / 2),
                chars: grilloBinary.split(''),
                startTime: 5000
            }
        };

        // Estado de las gotas
        const drops = [];
        const specialDrops = [];
        const fixedChars = [];

        for (let i = 0; i < columns; i++) {
            drops[i] = Math.random() * -100;
        }

        const binary = '01';
        let animationTime = 0;

        // Crear gotas especiales para los nombres de forma aleatoria
        function createSpecialDrops() {
            const allDrops = [];
            
            // Recopilar todos los caracteres de todos los nombres
            Object.keys(namePositions).forEach(name => {
                const pos = namePositions[name];
                pos.chars.forEach((char, index) => {
                    allDrops.push({
                        char: char,
                        col: pos.startCol + index,
                        targetY: pos.y,
                        currentY: Math.random() * -100 - 50,
                        speed: 0.6 + Math.random() * 0.6,
                        startTime: 0,
                        stopped: false,
                        name: name
                    });
                });
            });
            
            // Mezclar aleatoriamente
            for (let i = allDrops.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allDrops[i], allDrops[j]] = [allDrops[j], allDrops[i]];
            }
            
            // Asignar tiempos de inicio aleatorios espaciados
            allDrops.forEach((drop, index) => {
                drop.startTime = 500 + (index * 80) + Math.random() * 200;
                specialDrops.push(drop);
            });
        }

        createSpecialDrops();

        function draw() {
            animationTime += 33;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = fontSize + 'px monospace';

            // Dibujar caracteres fijos (ya llegaron a su posici칩n)
            fixedChars.forEach(fc => {
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#0f0';
                ctx.fillText(fc.char, fc.col * fontSize, fc.y * fontSize);
                ctx.shadowBlur = 0;
            });

            // Dibujar gotas normales
            for (let i = 0; i < drops.length; i++) {
                // Verificar si esta columna tiene una gota especial activa
                const hasSpecialDrop = specialDrops.some(sd => 
                    sd.col === i && 
                    !sd.stopped && 
                    animationTime >= sd.startTime &&
                    Math.abs(sd.currentY - drops[i]) < 5
                );

                if (!hasSpecialDrop) {
                    const text = binary[Math.floor(Math.random() * binary.length)];
                    
                    const brightness = Math.random();
                    if (brightness > 0.95) {
                        ctx.fillStyle = '#fff';
                    } else if (brightness > 0.7) {
                        ctx.fillStyle = '#0f0';
                    } else {
                        ctx.fillStyle = '#0a0';
                    }

                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                }

                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                drops[i]++;
            }

            // Dibujar y actualizar gotas especiales
            specialDrops.forEach(sd => {
                if (animationTime < sd.startTime) return;

                if (!sd.stopped) {
                    // Efecto de brillo m치s intenso
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#0ff';
                    ctx.fillText(sd.char, sd.col * fontSize, sd.currentY * fontSize);
                    ctx.shadowBlur = 0;

                    sd.currentY += sd.speed;

                    // Verificar si lleg칩 a su posici칩n
                    if (sd.currentY >= sd.targetY) {
                        sd.stopped = true;
                        fixedChars.push({
                            char: sd.char,
                            col: sd.col,
                            y: sd.targetY
                        });
                    }
                }
            });
        }

        setInterval(draw, 33);

        window.addEventListener('resize', () => {
            // Banner fijo, no necesita resize
        });
    </script>
</body>
</html>
