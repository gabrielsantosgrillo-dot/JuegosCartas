<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel Santos Grillo - Binary Matrix Loop</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            font-family: 'Courier New', monospace; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
        }
        canvas { display: block; background: #000; width: 100%; height: 300px; max-width: 1200px; }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>
    <script>
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 300;
        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);
        const binary = '01';

        function textToBinary(text) {
            return text.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');
        }

        // Variables de estado globales
        let drops, specialDrops, fixedChars, eraserDrops, allCharsFixed, allCharsFixedTime, animationTime, resetTriggered;

        function init() {
            // Reiniciar/Inicializar todas las variables
            drops = [];
            specialDrops = [];
            fixedChars = [];
            eraserDrops = [];
            allCharsFixed = false;
            allCharsFixedTime = 0;
            animationTime = 0;
            resetTriggered = false;

            for (let i = 0; i < columns; i++) {
                drops[i] = Math.random() * -100;
            }

            const namePositions = {
                gabriel: { y: 5, startCol: Math.floor((columns - 56) / 2), chars: textToBinary("GABRIEL").split('') },
                santos: { y: 10, startCol: Math.floor((columns - 48) / 2), chars: textToBinary("SANTOS").split('') },
                grillo: { y: 15, startCol: Math.floor((columns - 48) / 2), chars: textToBinary("GRILLO").split('') }
            };

            const allDrops = [];
            Object.keys(namePositions).forEach(name => {
                const pos = namePositions[name];
                pos.chars.forEach((char, index) => {
                    allDrops.push({
                        char: char, col: pos.startCol + index, targetY: pos.y,
                        currentY: Math.random() * -100 - 50, speed: 0.6 + Math.random() * 0.6,
                        startTime: 500 + (allDrops.length * 80) + Math.random() * 200,
                        stopped: false
                    });
                });
            });
            specialDrops = allDrops;
        }

        function createEraserDrops() {
            const allFixedPositions = [...fixedChars];
            allFixedPositions.forEach((fc, index) => {
                eraserDrops.push({
                    col: fc.col, targetY: fc.y, currentY: -5, speed: 0.5 + Math.random() * 0.5,
                    startTime: allCharsFixedTime + 2000 + (index * 40),
                    erasing: false, erased: false, targetChar: fc
                });
            });
        }

        function draw() {
            animationTime += 33;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = fontSize + 'px monospace';

            // 1. Lógica de fijación de nombres
            if (!allCharsFixed && fixedChars.length === specialDrops.length) {
                allCharsFixed = true;
                allCharsFixedTime = animationTime;
                createEraserDrops();
            }

            // 2. Dibujar caracteres fijos o en proceso de borrado
            fixedChars.forEach(fc => {
                if (!fc.erased && !fc.beingErased) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 15; ctx.shadowColor = '#0f0';
                    ctx.fillText(fc.char, fc.col * fontSize, fc.y * fontSize);
                    ctx.shadowBlur = 0;
                } else if (fc.beingErased && !fc.erased) {
                    ctx.fillStyle = '#0f0';
                    ctx.fillText(fc.char, fc.col * fontSize, fc.erasingY * fontSize);
                }
            });

            // 3. Gotas de lluvia normales
            for (let i = 0; i < drops.length; i++) {
                ctx.fillStyle = Math.random() > 0.95 ? '#fff' : '#0a0';
                ctx.fillText(binary[Math.floor(Math.random() * 2)], i * fontSize, drops[i] * fontSize);
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }

            // 4. Gotas especiales (formando nombres)
            specialDrops.forEach(sd => {
                if (animationTime < sd.startTime || sd.stopped) return;
                ctx.fillStyle = '#fff';
                ctx.fillText(sd.char, sd.col * fontSize, sd.currentY * fontSize);
                sd.currentY += sd.speed;
                if (sd.currentY >= sd.targetY) {
                    sd.stopped = true;
                    fixedChars.push({ char: sd.char, col: sd.col, y: sd.targetY, erased: false, beingErased: false });
                }
            });

            // 5. Gotas borradoras y REINICIO
            let activeErasers = 0;
            eraserDrops.forEach(ed => {
                if (animationTime < ed.startTime || ed.erased) return;
                activeErasers++;
                if (!ed.erasing) {
                    ed.currentY += ed.speed;
                    if (ed.currentY >= ed.targetY) {
                        ed.erasing = true;
                        ed.targetChar.beingErased = true;
                        ed.targetChar.erasingY = ed.targetY;
                    }
                } else {
                    ed.targetChar.erasingY += ed.speed;
                    if (ed.targetChar.erasingY * fontSize > canvas.height) {
                        ed.erased = true;
                        ed.targetChar.erased = true;
                    }
                }
            });

            // 6. Si ya no hay borradores activos y todo se borró, esperar 5 seg y reiniciar
            if (allCharsFixed && activeErasers === 0 && !resetTriggered) {
                resetTriggered = true;
                setTimeout(init, 5000); // 5000ms = 5 segundos
            }
        }

        init();
        setInterval(draw, 33);
    </script>
</body>
</html>
