<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gabriel Santos Grillo - Binary Matrix</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            display: block;
            background: #000;
            width: 100%;
            height: 300px;
            max-width: 1200px;
        }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>

    <script>
        function textToBinary(text) {
            return text.split('').map(char => {
                return char.charCodeAt(0).toString(2).padStart(8, '0');
            }).join('  '); // Dos espacios entre cada letra
        }

        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');

        canvas.width = 1200;
        canvas.height = 300;

        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);

        // Nombres en binario
        const gabrielBinary = textToBinary("GABRIEL");
        const santosBinary = textToBinary("SANTOS");
        const grilloBinary = textToBinary("GRILLO");

        // Calcular posiciones centradas para todos los nombres
        // GABRIEL = 7 letras = 56 chars binarios
        // SANTOS = 6 letras = 48 chars binarios  
        // GRILLO = 6 letras = 48 chars binarios
        
        const gabrielLen = gabrielBinary.length;
        const santosLen = santosBinary.length;
        const grilloLen = grilloBinary.length;
        
        const namePositions = {
            gabriel: { 
                y: 5,
                startCol: Math.floor((columns - gabrielLen) / 2),
                chars: gabrielBinary.split(''),
                startTime: 1000
            },
            santos: { 
                y: 10,
                startCol: Math.floor((columns - santosLen) / 2),
                chars: santosBinary.split(''),
                startTime: 3000
            },
            grillo: { 
                y: 15,
                startCol: Math.floor((columns - grilloLen) / 2),
                chars: grilloBinary.split(''),
                startTime: 5000
            }
        };

        // Estado de las gotas
        const drops = [];
        let specialDrops = [];
        let fixedChars = [];
        let eraserDrops = [];
        let allCharsFixed = false;
        let allCharsFixedTime = 0;
        let allCharsErased = false;
        let cycleStartTime = 0;

        for (let i = 0; i < columns; i++) {
            drops[i] = Math.random() * -100;
        }

        const binary = '01';
        let animationTime = 0;

        // Crear gotas especiales para los nombres de forma aleatoria
        function createSpecialDrops() {
            specialDrops = [];
            const allDrops = [];
            
            // Recopilar todos los caracteres de todos los nombres
            Object.keys(namePositions).forEach(name => {
                const pos = namePositions[name];
                pos.chars.forEach((char, index) => {
                    allDrops.push({
                        char: char,
                        col: pos.startCol + index,
                        targetY: pos.y,
                        currentY: Math.random() * -100 - 50,
                        speed: 0.6 + Math.random() * 0.6,
                        startTime: 0,
                        stopped: false,
                        name: name
                    });
                });
            });
            
            // Mezclar aleatoriamente
            for (let i = allDrops.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allDrops[i], allDrops[j]] = [allDrops[j], allDrops[i]];
            }
            
            // Asignar tiempos de inicio aleatorios espaciados
            allDrops.forEach((drop, index) => {
                drop.startTime = cycleStartTime + 500 + (index * 80) + Math.random() * 200;
                specialDrops.push(drop);
            });
        }

        // Crear gotas borradoras después de que todo esté fijo
        function createEraserDrops() {
            eraserDrops = [];
            const allFixedPositions = [...fixedChars];
            
            // Mezclar aleatoriamente
            for (let i = allFixedPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allFixedPositions[i], allFixedPositions[j]] = [allFixedPositions[j], allFixedPositions[i]];
            }
            
            // Crear gotas que borrarán cada carácter
            allFixedPositions.forEach((fc, index) => {
                eraserDrops.push({
                    col: fc.col,
                    targetY: fc.y,
                    currentY: -5,
                    speed: 0.5 + Math.random() * 0.5,
                    startTime: allCharsFixedTime + 5000 + (index * 60),
                    erasing: false,
                    erased: false,
                    targetChar: fc
                });
            });
        }

        // Reiniciar el ciclo
        function resetCycle() {
            specialDrops = [];
            fixedChars = [];
            eraserDrops = [];
            allCharsFixed = false;
            allCharsFixedTime = 0;
            allCharsErased = false;
            cycleStartTime = animationTime;
            createSpecialDrops();
        }

        createSpecialDrops();

        function draw() {
            animationTime += 33;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = fontSize + 'px monospace';

            // Verificar si todos los caracteres están fijos
            if (!allCharsFixed && fixedChars.length === specialDrops.length) {
                allCharsFixed = true;
                allCharsFixedTime = animationTime;
                createEraserDrops();
            }

            // Dibujar caracteres fijos (que aún no han sido borrados)
            fixedChars.forEach(fc => {
                if (!fc.erased && !fc.beingErased) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 3;
                    ctx.shadowColor = '#0f0';
                    ctx.fillText(fc.char, fc.col * fontSize, fc.y * fontSize);
                    ctx.shadowBlur = 0;
                } else if (fc.beingErased) {
                    // Dibujar carácter siendo arrastrado
                    ctx.fillStyle = '#ccc';
                    ctx.shadowBlur = 2;
                    ctx.shadowColor = '#0a0';
                    ctx.fillText(fc.char, fc.col * fontSize, fc.erasingY * fontSize);
                    ctx.shadowBlur = 0;
                }
            });

            // Dibujar gotas normales
            for (let i = 0; i < drops.length; i++) {
                const hasSpecialDrop = specialDrops.some(sd => 
                    sd.col === i && 
                    !sd.stopped && 
                    animationTime >= sd.startTime &&
                    Math.abs(sd.currentY - drops[i]) < 5
                );

                const hasEraserDrop = eraserDrops.some(ed =>
                    ed.col === i &&
                    !ed.erased &&
                    animationTime >= ed.startTime &&
                    Math.abs(ed.currentY - drops[i]) < 5
                );

                if (!hasSpecialDrop && !hasEraserDrop) {
                    const text = binary[Math.floor(Math.random() * binary.length)];
                    
                    const brightness = Math.random();
                    if (brightness > 0.95) {
                        ctx.fillStyle = '#fff';
                    } else if (brightness > 0.7) {
                        ctx.fillStyle = '#0f0';
                    } else {
                        ctx.fillStyle = '#0a0';
                    }

                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                }

                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                drops[i]++;
            }

            // Dibujar y actualizar gotas especiales (creación)
            specialDrops.forEach(sd => {
                if (animationTime < sd.startTime) return;

                if (!sd.stopped) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = '#0f0';
                    ctx.fillText(sd.char, sd.col * fontSize, sd.currentY * fontSize);
                    ctx.shadowBlur = 0;

                    sd.currentY += sd.speed;

                    if (sd.currentY >= sd.targetY) {
                        sd.stopped = true;
                        fixedChars.push({
                            char: sd.char,
                            col: sd.col,
                            y: sd.targetY,
                            erased: false,
                            beingErased: false
                        });
                    }
                }
            });

            // Dibujar y actualizar gotas borradoras
            eraserDrops.forEach(ed => {
                if (animationTime < ed.startTime || ed.erased) return;

                if (!ed.erasing) {
                    // Gota borrador cayendo con brillo sutil
                    ctx.fillStyle = '#f00';
                    ctx.shadowBlur = 4;
                    ctx.shadowColor = '#f00';
                    ctx.fillText(binary[Math.floor(Math.random() * 2)], ed.col * fontSize, ed.currentY * fontSize);
                    ctx.shadowBlur = 0;

                    ed.currentY += ed.speed;

                    // Verificar si alcanzó el carácter objetivo
                    if (ed.currentY >= ed.targetY) {
                        ed.erasing = true;
                        ed.targetChar.beingErased = true;
                        ed.targetChar.erasingY = ed.targetY;
                    }
                } else {
                    // Arrastrar el carácter hacia abajo
                    ed.targetChar.erasingY += ed.speed;

                    // Si llegó al fondo, marcarlo como borrado
                    if (ed.targetChar.erasingY * fontSize > canvas.height) {
                        ed.erased = true;
                        ed.targetChar.erased = true;
                    }
                }
            });

            // Verificar si todos los caracteres han sido borrados
            if (allCharsFixed && !allCharsErased && eraserDrops.length > 0) {
                const allErased = eraserDrops.every(ed => ed.erased);
                if (allErased) {
                    allCharsErased = true;
                    // Esperar 5 segundos antes de reiniciar
                    setTimeout(() => {
                        resetCycle();
                    }, 5000);
                }
            }
        }

        setInterval(draw, 33);

        window.addEventListener('resize', () => {
            // Banner fijo, no necesita resize
        });
    </script>
</body>
</html>
